///! Thing
use std::collections::HashMap;

use serde::{Deserialize, Deserializer};
use serde_derive::{Deserialize, Serialize};

use chrono::{DateTime, Utc};

use crate::utils::serde::parse_intbool;

mod entries_filter;
mod format;
mod new_entry;
mod patch_entry;
mod user;

// re-export submodule types
pub use self::entries_filter::{EntriesFilter, SortBy, SortOrder};
pub use self::format::Format;
pub use self::new_entry::NewEntry;
pub use self::patch_entry::PatchEntry;
pub use self::user::{NewlyRegisteredInfo, RegisterInfo, User};

/// The type used as an ID for all data structures. Declared for clarity.
pub type ID = u32;

/// This is implemented so that an Entry can be used interchangably with an ID
/// for some client methods. For convenience.
impl From<Entry> for ID {
    fn from(entry: Entry) -> Self {
        entry.id
    }
}

/// The type returned from `check_exists`. The format is URL: ID. If ID is None,
/// then that url doesn't exist in the db.
pub type ExistsInfo = HashMap<String, Option<ID>>;

/// used internally to store information about the oauth token
#[derive(Deserialize, Debug)]
pub(crate) struct TokenInfo {
    pub access_token: String,
    pub expires_in: u32,
    pub token_type: String,
    pub scope: Option<String>,
    pub refresh_token: String,
}

/// configuration to use to init a `Client`.
#[derive(Debug)]
pub struct Config {
    pub client_id: String,
    pub client_secret: String,
    pub username: String,
    pub password: String,
    pub base_url: String,
}

/// type alias: a list of entries as returned from some endpoints
pub type Entries = Vec<Entry>;

/// A struct representing an entry from wallabag (a full saved article including
/// all annotations and tags; annotations and tags do not need to be requested
/// separately).
#[derive(Deserialize, Debug)]
pub struct Entry {
    pub annotations: Option<Annotations>,
    pub content: Option<String>,
    pub created_at: DateTime<Utc>,
    pub domain_name: Option<String>,
    pub headers: Option<String>,
    pub http_status: Option<String>,
    pub id: ID,

    #[serde(deserialize_with = "parse_intbool")]
    pub is_archived: bool,

    #[serde(deserialize_with = "parse_intbool")]
    pub is_public: bool,

    #[serde(deserialize_with = "parse_intbool")]
    pub is_starred: bool,
    pub language: Option<String>,
    pub mimetype: Option<String>,
    pub origin_url: Option<String>,
    pub preview_picture: Option<String>,
    pub published_at: Option<DateTime<Utc>>,
    pub published_by: Option<String>,

    /// estimated reading time in minutes (appears to be generated by the
    /// server)
    pub reading_time: u32,

    pub starred_at: Option<DateTime<Utc>>,
    pub tags: Tags,
    pub title: Option<String>,
    pub uid: Option<String>,
    pub updated_at: DateTime<Utc>,
    pub url: Option<String>,
    pub user_email: String,
    pub user_id: ID,
    pub user_name: String,
}

/// A struct representing a deleted entry from wallabag (a full saved article including
/// annotations and tags). The only difference from the full entry is that this
/// doesn't have an id. Only used internally because a full entry gets
/// reconstituted before being returned to the client.
#[derive(Deserialize, Debug)]
pub(crate) struct DeletedEntry {
    pub annotations: Option<Annotations>,
    pub content: Option<String>,
    pub created_at: DateTime<Utc>,
    pub domain_name: Option<String>,
    pub headers: Option<String>,
    pub http_status: Option<String>,

    #[serde(deserialize_with = "parse_intbool")]
    pub is_archived: bool,

    #[serde(deserialize_with = "parse_intbool")]
    pub is_public: bool,

    #[serde(deserialize_with = "parse_intbool")]
    pub is_starred: bool,
    pub language: Option<String>,
    pub mimetype: Option<String>,
    pub origin_url: Option<String>,
    pub preview_picture: Option<String>,
    pub published_at: Option<DateTime<Utc>>,
    pub published_by: Option<String>,
    pub reading_time: u32,
    pub starred_at: Option<DateTime<Utc>>,
    pub tags: Tags,
    pub title: Option<String>,
    pub uid: Option<String>,
    pub updated_at: DateTime<Utc>,
    pub url: Option<String>,
    pub user_email: String,
    pub user_id: ID,
    pub user_name: String,
}

/// Type alias for clarity.
pub type Annotations = Vec<Annotation>;

/// Represents an annotation as returned from the api.
#[derive(Deserialize, Serialize, Debug)]
pub struct Annotation {
    pub annotator_schema_version: String,
    pub created_at: DateTime<Utc>,
    pub id: ID,
    pub quote: String,
    pub ranges: Vec<Range>,
    pub text: String,
    pub updated_at: DateTime<Utc>,
    pub user: Option<String>,
}

/// Represents an annotation to be created (hence no ID yet).
#[derive(Serialize, Debug)]
pub struct NewAnnotation {
    pub quote: String,
    pub ranges: Vec<Range>,
    pub text: String,
    pub user: Option<String>,
}

/// Internal struct for deserializing a response upon checking the existance of
/// a url.
#[derive(Deserialize, Debug)]
pub(crate) struct ExistsResponse {
    pub exists: Option<ID>,
}

/// Range as used in an `Annotation`. Shows where the annotation is in the
/// content.
///
/// TODO: research what the fields mean.
#[derive(Deserialize, Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct Range {
    pub end: Option<String>,
    pub end_offset: String,
    pub start: Option<String>,
    pub start_offset: String,
}

/// List of tags declared for clarity.
pub type Tags = Vec<Tag>;

/// Represents a tag from the api.
#[derive(Deserialize, Debug)]
pub struct Tag {
    pub id: ID,
    pub label: String,
    pub slug: String,
}

/// Convenience method to use an ID or Tag interchangably in client methods.
impl From<Tag> for ID {
    fn from(tag: Tag) -> Self {
        tag.id
    }
}

/// Represents a deleted tag, since deleted tags don't come with IDs.
#[derive(Deserialize, Debug)]
pub struct DeletedTag {
    pub label: String,
    pub slug: String,
}

/// Internal struct for retrieving a list of entries from the api when
/// paginated.
#[derive(Deserialize, Debug)]
pub(crate) struct PaginatedEntries {
    pub limit: u32,
    pub page: u32,
    pub pages: u32,
    pub total: u32,
    pub _embedded: EmbeddedEntries,
}

/// Entries as stored in `PaginatedEntries`.
#[derive(Deserialize, Debug)]
pub(crate) struct EmbeddedEntries {
    pub items: Entries,
}

// a little trick to get around having to provide type annotations for a unit or
// none value when passing to url serializer
#[derive(Serialize, Debug)]
pub(crate) struct Unit {}
pub(crate) static UNIT: &Unit = &Unit {};
